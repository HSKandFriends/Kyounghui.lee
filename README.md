# Kyounghui.lee
코딩 테스트 연습.


# Stack
스택은 LIFO(후입 선출)을 의미합니다.
스택이 가지는 method는 총 3가지(혹은 4가지)

1. Push(value) - Stack에 값을 밀어 넣습니다.
2. Pop() - 가장 마지막 숫자를 제거하면서 값을 확인합니다.
3. Top() - 가장 마지막 숫자의 값을 확인합니다.
(4. Len() - 현재 스택에 밀어넣어진 값의 개수를 확인합니다.)

스택을 구현하는 방법은 대표적으로 2가지로, 하나는 Array로, 하나는 Linked List로 구현하는 것입니다.
Array로 구현하는 경우는 길이가 정해져 있는 단점이 있지만 속도가 빠르다는 강점이 있습니다.
반대로, Linked List로 구현하는 경우 memory가 허락하는 한 무한대의 길이를 가질 수 있지만 속도가 느리다는 단점이 있습니다.(Cache Hit/Miss에 대해 공부해 보세요!)

Python으로 간단하게 구현해 보고 시간이 남는다면 C언어로도 구현해 보세요.


# Queue
큐는 FIFO(선입 선출)을 의미합니다.
큐가 가지는 method는 총 3가지(혹은 4가지)

1. Append(value) - Queue에 값을 밀어 넣습니다.
2. Remove() - 가장 앞에 입력된 숫자를 제거하면서 값을 확인합니다.
3. Head() - 가장 앞에 입력된 숫자를 확인합니다.
(4. Len() - 현재 큐에 밀어넣어진 값의 개수를 확인합니다.)

큐를 구현하는 방법 역시 스택과 동일합니다.
다만, 큐에 Linked List를 활용하는 방법은 일반적으로 권장하지 않습니다. 그 이유는, Tail을 알 수 없는 Linked List의 특징 때문입니다.
Linked List를 사용하려면 Singly Linked List가 아닌 Doubly Linked List를 사용하는 것을 권장하며, 이 경우 Queue 보다는 양방향 Append/Remove가 가능한 Deque(Double Ended Queue)를 구현하길 권장합니다.



# 알고리즘
## 최초의 알고리즘
유클리드가 고안한 인류사 최초의 알고리즘으로 GCD 구하는 법이 있습니다.
GCD는 최대공약수입니다. 최대공약수가 뭔진 아시죠?
최대공약수를 구하는 것으로 알고리즘에 대해 배워보겠습니다.
최대공약수는 초등학교 수학에서 배우는 개념이라 따로 설명하진 않겠습니다.

### 약수 구하기
최대 공약수를 구하려면 우선 약수를 구해야겠죠?

https://www.acmicpc.net/problem/2501

### GCD(최대공약수)
이제 약수를 구했으니 최대 공약수를 구해보도록 합시다.
초등학교 때 배운 방식으로 구현해 보시지요.

https://www.acmicpc.net/problem/1850

최초의 알고리즘인 유클리드 호제법을 통해 GCD를 구해보시는 것은 어떨까요?
기본적으로는 재귀함수를 사용하여 구하는 방법이 있고, While문을 사용하여 구하는 방법이 있습니다.
(재귀함수는 기본적으로 함수의 최대 depth 문제도 있고 메모리 사용량도 많으며 속도도 느려 비추천합니다.)


## LCM(최소공배수)
GCD를 구했으면 LCM도 구해봐야겠지요?
3분 드립니다.

https://www.acmicpc.net/problem/2609


## 피보나치 수열
Basic 단골문제 피보나치 수열입니다.
1 1 2 3 5 8 13 ... 아시죠?
위 GCD와 비슷한 방식으로 문제를 풀 수 있습니다.

https://www.acmicpc.net/problem/24416


## 소수 구하기(Prime Number)
소수의 개념은 아시죠?
1과 자기 자신으로만 나누어지는 숫자를 의마합니다.
어떤 수가 소수인지 확인하려면 기본적으로 O(N)의 시간이 필요합니다.
모든 수를 나누어 봐야 하기 때문입니다.
하지만, O(N)이 아닌 O(N^0.5)로도 계산이 가능하다는 사실을 알고 계신가요?(힌트: 약수 구하기)

https://www.acmicpc.net/problem/9091


## 에라토스테네스의 체
한 번에 하나의 소수만 확인하는 게 아니라 n까지의 모든 자연수 중 소수를 찾는 방법입니다.
기본적으로, O(N^0.5)를 n번 반복해야 해서 O(N^1.5)의 시간이 걸릴 것 같지만 아닙니다.
실제로 걸리는 시간은 O(NlogN)입니다.(실제로는 O(NloglogN) 이라고 합니다)

왜일까요?

https://www.acmicpc.net/problem/1929


## 동적 프로그래밍(Dynamic Programing)
에라토스테네스의 체는 동적 프로그래밍의 방식 중 하나입니다.(엄밀히 말하면 아닐수도...?)
Memoization이라고 하는 방식인데 기존의 계산 결과를 저장해 두었다가 다음 계산에 사용하는 것입니다.
또 다른 동적 프로그래밍의 방식은 수학시간에 배운 점화식 입니다.
수학적 귀납법으로 접근하여 점화식을 구해 계산하는 것입니다.

https://www.acmicpc.net/problem/1904
https://www.acmicpc.net/problem/2579
https://school.programmers.co.kr/learn/courses/30/lessons/43105